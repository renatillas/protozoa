//// Generated by Protozoa from ./src/protozoa_example/proto/protozoa_example.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m protozoa
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/dict
import gleam/int
import gleam/list
import gleam/option.{None, Some}
import gleam/result
import gleam/string
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type UserRole {
  UNKNOWN
  ADMIN
  USER
  GUEST
}

pub type User {
  User(
    id: Int,
    name: String,
    email: String,
    created_at: Timestamp,
    is_active: Bool,
    role: UserRole,
    tags: List(String),
    bio: StringValue,
  )
}

pub type SimpleMessageData {
  TextData(String)
  NumericData(Int)
  BinaryData(BitArray)
}

pub type SimpleMessage {
  SimpleMessage(
    id: String,
    description: String,
    enabled: Bool,
    data: option.Option(SimpleMessageData),
  )
}

pub type Timestamp {
  Timestamp(seconds: Int, nanos: Int)
}

pub type StringValue {
  StringValue(value: String)
}

pub fn encode_simplemessage(simplemessage: SimpleMessage) -> BitArray {
  encode.message([
    encode.string_field(1, simplemessage.id),
    encode.string_field(5, simplemessage.description),
    encode.bool_field(6, simplemessage.enabled),
    case simplemessage.data {
      Some(oneof_value) -> {
        case oneof_value {
          TextData(value) -> encode.string_field(2, value)
          NumericData(value) -> encode.int64_field(3, value)
          BinaryData(value) ->
            encode.field(
              4,
              wire.LengthDelimited,
              encode.length_delimited(value),
            )
        }
      }
      None -> <<>>
    },
  ])
}

pub fn encode_user(user: User) -> BitArray {
  let tags_fields = list.map(user.tags, fn(v) { encode.string_field(7, v) })
  encode.message(
    list.flatten([
      tags_fields,
      [encode.int32_field(1, user.id)],
      [encode.string_field(2, user.name)],
      [encode.string_field(3, user.email)],
      [
        encode.field(
          4,
          wire.LengthDelimited,
          encode.length_delimited(encode_timestamp(user.created_at)),
        ),
      ],
      [encode.bool_field(5, user.is_active)],
      [encode.int32_field(6, encode_userrole_value(user.role))],
      [
        encode.field(
          8,
          wire.LengthDelimited,
          encode.length_delimited(encode_stringvalue(user.bio)),
        ),
      ],
    ]),
  )
}

pub fn encode_timestamp(timestamp: Timestamp) -> BitArray {
  encode.message([
    encode.int64_field(1, timestamp.seconds),
    encode.int32_field(2, timestamp.nanos),
  ])
}

pub fn encode_stringvalue(stringvalue: StringValue) -> BitArray {
  encode.message([
    encode.string_field(1, stringvalue.value),
  ])
}

fn oneof_data_decoder() -> decode.Decoder(option.Option(SimpleMessageData)) {
  decode.from_field_dict(fn(fields) {
    case dict.get(fields, 2) {
      Ok([field, ..]) -> {
        case decode.string_field(field) {
          Ok(value) -> Ok(option.Some(TextData(value)))
          Error(_) -> Ok(option.None)
        }
      }
      _ -> {
        case dict.get(fields, 3) {
          Ok([field, ..]) -> {
            case decode.int64_field(field) {
              Ok(value) -> Ok(option.Some(NumericData(value)))
              Error(_) -> Ok(option.None)
            }
          }
          _ -> {
            case dict.get(fields, 4) {
              Ok([field, ..]) -> {
                case decode.bytes_field(field) {
                  Ok(value) -> Ok(option.Some(BinaryData(value)))
                  Error(_) -> Ok(option.None)
                }
              }
              _ -> Ok(option.None)
            }
          }
        }
      }
    }
  })
}

pub fn simplemessage_decoder() -> decode.Decoder(SimpleMessage) {
  use id <- decode.then(decode.string_with_default(1, ""))
  use description <- decode.then(decode.string_with_default(5, ""))
  use enabled <- decode.then(decode.bool_with_default(6, False))
  use data <- decode.then(oneof_data_decoder())
  decode.success(SimpleMessage(
    id: id,
    description: description,
    enabled: enabled,
    data: data,
  ))
}

pub fn decode_simplemessage(
  data: BitArray,
) -> Result(SimpleMessage, List(decode.DecodeError)) {
  decode.run(data, simplemessage_decoder())
}

pub fn user_decoder() -> decode.Decoder(User) {
  use id <- decode.then(decode.int32_with_default(1, 0))
  use name <- decode.then(decode.string_with_default(2, ""))
  use email <- decode.then(decode.string_with_default(3, ""))
  use created_at <- decode.then(decode.nested_message(4, timestamp_decoder()))
  use is_active <- decode.then(decode.bool_with_default(5, False))
  use role <- decode.then(decode_userrole_field(6))
  use tags <- decode.then(decode.repeated_string(7))
  use bio <- decode.then(decode.nested_message(8, stringvalue_decoder()))
  decode.success(User(
    id: id,
    name: name,
    email: email,
    created_at: created_at,
    is_active: is_active,
    role: role,
    tags: tags,
    bio: bio,
  ))
}

pub fn decode_user(data: BitArray) -> Result(User, List(decode.DecodeError)) {
  decode.run(data, user_decoder())
}

pub fn timestamp_decoder() -> decode.Decoder(Timestamp) {
  use seconds <- decode.then(decode.int64_with_default(1, 0))
  use nanos <- decode.then(decode.int32_with_default(2, 0))
  decode.success(Timestamp(seconds: seconds, nanos: nanos))
}

pub fn decode_timestamp(
  data: BitArray,
) -> Result(Timestamp, List(decode.DecodeError)) {
  decode.run(data, timestamp_decoder())
}

pub fn stringvalue_decoder() -> decode.Decoder(StringValue) {
  use value <- decode.then(decode.string_with_default(1, ""))
  decode.success(StringValue(value: value))
}

pub fn decode_stringvalue(
  data: BitArray,
) -> Result(StringValue, List(decode.DecodeError)) {
  decode.run(data, stringvalue_decoder())
}

pub fn encode_userrole_value(value: UserRole) -> Int {
  case value {
    UNKNOWN -> 0
    ADMIN -> 1
    USER -> 2
    GUEST -> 3
  }
}

pub fn decode_userrole_field(field_num: Int) -> decode.Decoder(UserRole) {
  decode.field(field_num, fn(field) {
    use value <- result.try(decode.int32_field(field))
    case value {
      0 -> Ok(UNKNOWN)
      1 -> Ok(ADMIN)
      2 -> Ok(USER)
      3 -> Ok(GUEST)
      _ ->
        Error(
          decode.DecodeError(
            expected: "valid userrole value",
            found: "Unknown userrole value: " <> string.inspect(value),
            path: [],
          ),
        )
    }
  })
}

pub fn decode_userrole_value(value: Int) -> Result(UserRole, String) {
  case value {
    0 -> Ok(UNKNOWN)
    1 -> Ok(ADMIN)
    2 -> Ok(USER)
    3 -> Ok(GUEST)
    _ -> Error("Unknown userrole value: " <> int.to_string(value))
  }
}
