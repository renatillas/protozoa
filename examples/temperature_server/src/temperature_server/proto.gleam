//// Generated by Protozoa from google/api/annotations.proto, google/api/http.proto, temperature_server.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/http/request
import gleam/http/response
import gleam/int
import gleam/list
import gleam/string
import protozoa/decode
import protozoa/encode

pub type TemperatureGetTemperatureRequest {
  TemperatureGetTemperatureRequest(
    sensor_id: String,
    location: String,
    include_history: Bool,
  )
}

pub fn encode_temperature_get_temperature_request(
  temperature_get_temperature_request: TemperatureGetTemperatureRequest,
) {
  encode.message([
    encode.string_field(1, temperature_get_temperature_request.sensor_id),
    encode.string_field(2, temperature_get_temperature_request.location),
    encode.bool_field(3, temperature_get_temperature_request.include_history),
  ])
}

pub fn temperature_get_temperature_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  use include_history <- decode.then(decode.bool_with_default(3, False))
  decode.success(TemperatureGetTemperatureRequest(
    sensor_id: sensor_id,
    location: location,
    include_history: include_history,
  ))
}

pub fn decode_temperature_get_temperature_request(data: BitArray) {
  decode.run(data, temperature_get_temperature_request_decoder())
}

pub type TemperatureCreateTemperatureRequest {
  TemperatureCreateTemperatureRequest(
    sensor_id: String,
    degrees: Int,
    unit: String,
    location: String,
  )
}

pub fn encode_temperature_create_temperature_request(
  temperature_create_temperature_request: TemperatureCreateTemperatureRequest,
) {
  encode.message([
    encode.string_field(1, temperature_create_temperature_request.sensor_id),
    encode.int32_field(2, temperature_create_temperature_request.degrees),
    encode.string_field(3, temperature_create_temperature_request.unit),
    encode.string_field(4, temperature_create_temperature_request.location),
  ])
}

pub fn temperature_create_temperature_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use unit <- decode.then(decode.string_with_default(3, ""))
  use location <- decode.then(decode.string_with_default(4, ""))
  decode.success(TemperatureCreateTemperatureRequest(
    sensor_id: sensor_id,
    degrees: degrees,
    unit: unit,
    location: location,
  ))
}

pub fn decode_temperature_create_temperature_request(data: BitArray) {
  decode.run(data, temperature_create_temperature_request_decoder())
}

pub type TemperatureUpdateTemperatureRequest {
  TemperatureUpdateTemperatureRequest(
    sensor_id: String,
    degrees: Int,
    unit: String,
    notes: String,
  )
}

pub fn encode_temperature_update_temperature_request(
  temperature_update_temperature_request: TemperatureUpdateTemperatureRequest,
) {
  encode.message([
    encode.string_field(1, temperature_update_temperature_request.sensor_id),
    encode.int32_field(2, temperature_update_temperature_request.degrees),
    encode.string_field(3, temperature_update_temperature_request.unit),
    encode.string_field(4, temperature_update_temperature_request.notes),
  ])
}

pub fn temperature_update_temperature_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use unit <- decode.then(decode.string_with_default(3, ""))
  use notes <- decode.then(decode.string_with_default(4, ""))
  decode.success(TemperatureUpdateTemperatureRequest(
    sensor_id: sensor_id,
    degrees: degrees,
    unit: unit,
    notes: notes,
  ))
}

pub fn decode_temperature_update_temperature_request(data: BitArray) {
  decode.run(data, temperature_update_temperature_request_decoder())
}

pub type TemperatureDeleteTemperatureRequest {
  TemperatureDeleteTemperatureRequest(sensor_id: String, location: String)
}

pub fn encode_temperature_delete_temperature_request(
  temperature_delete_temperature_request: TemperatureDeleteTemperatureRequest,
) {
  encode.message([
    encode.string_field(1, temperature_delete_temperature_request.sensor_id),
    encode.string_field(2, temperature_delete_temperature_request.location),
  ])
}

pub fn temperature_delete_temperature_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  decode.success(TemperatureDeleteTemperatureRequest(
    sensor_id: sensor_id,
    location: location,
  ))
}

pub fn decode_temperature_delete_temperature_request(data: BitArray) {
  decode.run(data, temperature_delete_temperature_request_decoder())
}

pub type TemperatureListTemperaturesRequest {
  TemperatureListTemperaturesRequest(location: String, limit: Int, offset: Int)
}

pub fn encode_temperature_list_temperatures_request(
  temperature_list_temperatures_request: TemperatureListTemperaturesRequest,
) {
  encode.message([
    encode.string_field(1, temperature_list_temperatures_request.location),
    encode.int32_field(2, temperature_list_temperatures_request.limit),
    encode.int32_field(3, temperature_list_temperatures_request.offset),
  ])
}

pub fn temperature_list_temperatures_request_decoder() {
  use location <- decode.then(decode.string_with_default(1, ""))
  use limit <- decode.then(decode.int32_with_default(2, 0))
  use offset <- decode.then(decode.int32_with_default(3, 0))
  decode.success(TemperatureListTemperaturesRequest(
    location: location,
    limit: limit,
    offset: offset,
  ))
}

pub fn decode_temperature_list_temperatures_request(data: BitArray) {
  decode.run(data, temperature_list_temperatures_request_decoder())
}

pub type TemperatureSearchTemperaturesRequest {
  TemperatureSearchTemperaturesRequest(
    min_degrees: Int,
    max_degrees: Int,
    location: String,
  )
}

pub fn encode_temperature_search_temperatures_request(
  temperature_search_temperatures_request: TemperatureSearchTemperaturesRequest,
) {
  encode.message([
    encode.int32_field(1, temperature_search_temperatures_request.min_degrees),
    encode.int32_field(2, temperature_search_temperatures_request.max_degrees),
    encode.string_field(3, temperature_search_temperatures_request.location),
  ])
}

pub fn temperature_search_temperatures_request_decoder() {
  use min_degrees <- decode.then(decode.int32_with_default(1, 0))
  use max_degrees <- decode.then(decode.int32_with_default(2, 0))
  use location <- decode.then(decode.string_with_default(3, ""))
  decode.success(TemperatureSearchTemperaturesRequest(
    min_degrees: min_degrees,
    max_degrees: max_degrees,
    location: location,
  ))
}

pub fn decode_temperature_search_temperatures_request(data: BitArray) {
  decode.run(data, temperature_search_temperatures_request_decoder())
}

pub type TemperatureTemperatureResponse {
  TemperatureTemperatureResponse(eval: String, degrees: Int, sensor_id: String)
}

pub fn encode_temperature_temperature_response(
  temperature_temperature_response: TemperatureTemperatureResponse,
) {
  encode.message([
    encode.string_field(1, temperature_temperature_response.eval),
    encode.int32_field(2, temperature_temperature_response.degrees),
    encode.string_field(3, temperature_temperature_response.sensor_id),
  ])
}

pub fn temperature_temperature_response_decoder() {
  use eval <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use sensor_id <- decode.then(decode.string_with_default(3, ""))
  decode.success(TemperatureTemperatureResponse(
    eval: eval,
    degrees: degrees,
    sensor_id: sensor_id,
  ))
}

pub fn decode_temperature_temperature_response(data: BitArray) {
  decode.run(data, temperature_temperature_response_decoder())
}

pub type TemperatureGetSensorRequest {
  TemperatureGetSensorRequest(sensor_id: String)
}

pub fn encode_temperature_get_sensor_request(
  temperature_get_sensor_request: TemperatureGetSensorRequest,
) {
  encode.message([
    encode.string_field(1, temperature_get_sensor_request.sensor_id),
  ])
}

pub fn temperature_get_sensor_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  decode.success(TemperatureGetSensorRequest(sensor_id: sensor_id))
}

pub fn decode_temperature_get_sensor_request(data: BitArray) {
  decode.run(data, temperature_get_sensor_request_decoder())
}

pub type TemperatureCreateSensorRequest {
  TemperatureCreateSensorRequest(
    sensor_id: String,
    location: String,
    type_: String,
  )
}

pub fn encode_temperature_create_sensor_request(
  temperature_create_sensor_request: TemperatureCreateSensorRequest,
) {
  encode.message([
    encode.string_field(1, temperature_create_sensor_request.sensor_id),
    encode.string_field(2, temperature_create_sensor_request.location),
    encode.string_field(3, temperature_create_sensor_request.type_),
  ])
}

pub fn temperature_create_sensor_request_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  use type_ <- decode.then(decode.string_with_default(3, ""))
  decode.success(TemperatureCreateSensorRequest(
    sensor_id: sensor_id,
    location: location,
    type_: type_,
  ))
}

pub fn decode_temperature_create_sensor_request(data: BitArray) {
  decode.run(data, temperature_create_sensor_request_decoder())
}

pub type TemperatureSensorResponse {
  TemperatureSensorResponse(
    sensor_id: String,
    location: String,
    type_: String,
    status: String,
  )
}

pub fn encode_temperature_sensor_response(
  temperature_sensor_response: TemperatureSensorResponse,
) {
  encode.message([
    encode.string_field(1, temperature_sensor_response.sensor_id),
    encode.string_field(2, temperature_sensor_response.location),
    encode.string_field(3, temperature_sensor_response.type_),
    encode.string_field(4, temperature_sensor_response.status),
  ])
}

pub fn temperature_sensor_response_decoder() {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  use type_ <- decode.then(decode.string_with_default(3, ""))
  use status <- decode.then(decode.string_with_default(4, ""))
  decode.success(TemperatureSensorResponse(
    sensor_id: sensor_id,
    location: location,
    type_: type_,
    status: status,
  ))
}

pub fn decode_temperature_sensor_response(data: BitArray) {
  decode.run(data, temperature_sensor_response_decoder())
}

// Service: TemperatureService

/// Error type for TemperatureService service
pub type TemperatureServiceError {
  TemperatureServiceNotFound
  TemperatureServiceUnauthorized
  TemperatureServiceBadRequest(String)
  TemperatureServiceInvalidRequest(String)
  TemperatureServiceInternalError(String)
  TemperatureServiceUnavailable(String)
}

// Service: SensorService

/// Error type for SensorService service
pub type SensorServiceError {
  SensorServiceNotFound
  SensorServiceUnauthorized
  SensorServiceBadRequest(String)
  SensorServiceInvalidRequest(String)
  SensorServiceInternalError(String)
  SensorServiceUnavailable(String)
}

/// Auto-generated service for TemperatureService
/// 
/// Layer 1: Core service functions (transport-agnostic BitArray -> Result)
/// Layer 2: HTTP adapters (gleam/http types, returns Result for middleware)
/// 
/// HTTP adapters return Result(Response, ServiceError) for middleware pattern
pub type TemperatureServiceRequestError {
  TemperatureServiceDecodeError(String)
  TemperatureServiceHandlerError(TemperatureServiceError)
}

pub fn get_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureGetTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_get_temperature_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureGetTemperatureRequest",
      ))
  }
}

pub fn create_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureCreateTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_create_temperature_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureCreateTemperatureRequest",
      ))
  }
}

pub fn update_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureUpdateTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_update_temperature_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureUpdateTemperatureRequest",
      ))
  }
}

pub fn delete_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureDeleteTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_delete_temperature_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureDeleteTemperatureRequest",
      ))
  }
}

pub fn list_temperatures_service(
  request_bytes: BitArray,
  handler: fn(TemperatureListTemperaturesRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_list_temperatures_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureListTemperaturesRequest",
      ))
  }
}

pub fn search_temperatures_service(
  request_bytes: BitArray,
  handler: fn(TemperatureSearchTemperaturesRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case
    decode.run(request_bytes, temperature_search_temperatures_request_decoder())
  {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError(
        "Failed to decode TemperatureSearchTemperaturesRequest",
      ))
  }
}

pub fn http_get_temperature(
  req: request.Request(BitArray),
  sensor_id: String,
  handler: fn(TemperatureGetTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let location = get_query_param_string(query_params, "location", "")
      let include_history =
        get_query_param_bool(query_params, "include_history", False)
      let proto_request =
        TemperatureGetTemperatureRequest(
          sensor_id: sensor_id,
          location: location,
          include_history: include_history,
        )
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_temperature_temperature_response(response)
          Ok(response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          ))
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError("Failed to parse query parameters"))
  }
}

pub fn http_create_temperature(
  req: request.Request(BitArray),
  handler: fn(TemperatureCreateTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  let request_bytes = req.body
  case create_temperature_service(request_bytes, handler) {
    Ok(response_bytes) ->
      Ok(response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      ))
    Error(service_error) -> Error(service_error)
  }
}

pub fn http_update_temperature(
  req: request.Request(BitArray),
  sensor_id: String,
  handler: fn(TemperatureUpdateTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  let request_bytes = req.body
  case update_temperature_service(request_bytes, handler) {
    Ok(response_bytes) ->
      Ok(response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      ))
    Error(service_error) -> Error(service_error)
  }
}

pub fn http_delete_temperature(
  req: request.Request(BitArray),
  location: String,
  sensor_id: String,
  handler: fn(TemperatureDeleteTemperatureRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let proto_request =
        TemperatureDeleteTemperatureRequest(
          sensor_id: sensor_id,
          location: location,
        )
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_temperature_temperature_response(response)
          Ok(response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          ))
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError("Failed to parse query parameters"))
  }
}

pub fn http_list_temperatures(
  req: request.Request(BitArray),
  handler: fn(TemperatureListTemperaturesRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let location = get_query_param_string(query_params, "location", "")
      let limit = get_query_param_int(query_params, "limit", 0)
      let offset = get_query_param_int(query_params, "offset", 0)
      let proto_request =
        TemperatureListTemperaturesRequest(
          location: location,
          limit: limit,
          offset: offset,
        )
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_temperature_temperature_response(response)
          Ok(response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          ))
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(TemperatureServiceDecodeError("Failed to parse query parameters"))
  }
}

pub fn http_search_temperatures(
  req: request.Request(BitArray),
  handler: fn(TemperatureSearchTemperaturesRequest) ->
    Result(TemperatureTemperatureResponse, TemperatureServiceError),
) {
  let request_bytes = req.body
  case search_temperatures_service(request_bytes, handler) {
    Ok(response_bytes) ->
      Ok(response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      ))
    Error(service_error) -> Error(service_error)
  }
}

/// Auto-generated service for SensorService
/// 
/// Layer 1: Core service functions (transport-agnostic BitArray -> Result)
/// Layer 2: HTTP adapters (gleam/http types, returns Result for middleware)
/// 
/// HTTP adapters return Result(Response, ServiceError) for middleware pattern
pub type SensorServiceRequestError {
  SensorServiceDecodeError(String)
  SensorServiceHandlerError(SensorServiceError)
}

pub fn get_sensor_service(
  request_bytes: BitArray,
  handler: fn(TemperatureGetSensorRequest) ->
    Result(TemperatureSensorResponse, SensorServiceError),
) {
  case decode.run(request_bytes, temperature_get_sensor_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_sensor_response(response))
        Error(err) -> Error(SensorServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(SensorServiceDecodeError(
        "Failed to decode TemperatureGetSensorRequest",
      ))
  }
}

pub fn create_sensor_service(
  request_bytes: BitArray,
  handler: fn(TemperatureCreateSensorRequest) ->
    Result(TemperatureSensorResponse, SensorServiceError),
) {
  case decode.run(request_bytes, temperature_create_sensor_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_sensor_response(response))
        Error(err) -> Error(SensorServiceHandlerError(err))
      }
    }
    Error(_) ->
      Error(SensorServiceDecodeError(
        "Failed to decode TemperatureCreateSensorRequest",
      ))
  }
}

fn get_query_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}

fn get_query_param_int(
  params: List(#(String, String)),
  key: String,
  default: Int,
) -> Int {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) ->
      case int.parse(value) {
        Ok(i) -> i
        Error(_) -> default
      }
    Error(_) -> default
  }
}

fn get_query_param_bool(
  params: List(#(String, String)),
  key: String,
  default: Bool,
) -> Bool {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) ->
      case string.lowercase(value) {
        s if s == "true" || s == "1" || s == "yes" -> True
        s if s == "false" || s == "0" || s == "no" -> False
        _ -> default
      }
    Error(_) -> default
  }
}
