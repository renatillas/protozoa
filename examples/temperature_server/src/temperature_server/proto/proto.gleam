//// Generated by Protozoa from ./src/temperature_server/proto/temperature_server.proto, google/api/annotations.proto, google/api/http.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m protozoa
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/http/request
import gleam/http/response
import gleam/int
import gleam/list
import gleam/string
import protozoa/decode
import protozoa/encode

pub type GetTemperatureRequest {
  GetTemperatureRequest(
    sensor_id: String,
    location: String,
    include_history: Bool,
  )
}

pub type CreateTemperatureRequest {
  CreateTemperatureRequest(
    sensor_id: String,
    degrees: Int,
    unit: String,
    location: String,
  )
}

pub type UpdateTemperatureRequest {
  UpdateTemperatureRequest(
    sensor_id: String,
    degrees: Int,
    unit: String,
    notes: String,
  )
}

pub type DeleteTemperatureRequest {
  DeleteTemperatureRequest(sensor_id: String, location: String)
}

pub type ListTemperaturesRequest {
  ListTemperaturesRequest(location: String, limit: Int, offset: Int)
}

pub type SearchTemperaturesRequest {
  SearchTemperaturesRequest(
    min_degrees: Int,
    max_degrees: Int,
    location: String,
  )
}

pub type TemperatureResponse {
  TemperatureResponse(eval: String, degrees: Int, sensor_id: String)
}

pub fn encode_temperature_response(
  temperature_response: TemperatureResponse,
) -> BitArray {
  encode.message([
    encode.string_field(1, temperature_response.eval),
    encode.int32_field(2, temperature_response.degrees),
    encode.string_field(3, temperature_response.sensor_id),
  ])
}

pub fn encode_search_temperatures_request(
  search_temperatures_request: SearchTemperaturesRequest,
) -> BitArray {
  encode.message([
    encode.int32_field(1, search_temperatures_request.min_degrees),
    encode.int32_field(2, search_temperatures_request.max_degrees),
    encode.string_field(3, search_temperatures_request.location),
  ])
}

pub fn encode_list_temperatures_request(
  list_temperatures_request: ListTemperaturesRequest,
) -> BitArray {
  encode.message([
    encode.string_field(1, list_temperatures_request.location),
    encode.int32_field(2, list_temperatures_request.limit),
    encode.int32_field(3, list_temperatures_request.offset),
  ])
}

pub fn encode_delete_temperature_request(
  delete_temperature_request: DeleteTemperatureRequest,
) -> BitArray {
  encode.message([
    encode.string_field(1, delete_temperature_request.sensor_id),
    encode.string_field(2, delete_temperature_request.location),
  ])
}

pub fn encode_update_temperature_request(
  update_temperature_request: UpdateTemperatureRequest,
) -> BitArray {
  encode.message([
    encode.string_field(1, update_temperature_request.sensor_id),
    encode.int32_field(2, update_temperature_request.degrees),
    encode.string_field(3, update_temperature_request.unit),
    encode.string_field(4, update_temperature_request.notes),
  ])
}

pub fn encode_create_temperature_request(
  create_temperature_request: CreateTemperatureRequest,
) -> BitArray {
  encode.message([
    encode.string_field(1, create_temperature_request.sensor_id),
    encode.int32_field(2, create_temperature_request.degrees),
    encode.string_field(3, create_temperature_request.unit),
    encode.string_field(4, create_temperature_request.location),
  ])
}

pub fn encode_get_temperature_request(
  get_temperature_request: GetTemperatureRequest,
) -> BitArray {
  encode.message([
    encode.string_field(1, get_temperature_request.sensor_id),
    encode.string_field(2, get_temperature_request.location),
    encode.bool_field(3, get_temperature_request.include_history),
  ])
}

pub fn temperature_response_decoder() -> decode.Decoder(TemperatureResponse) {
  use eval <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use sensor_id <- decode.then(decode.string_with_default(3, ""))
  decode.success(TemperatureResponse(
    eval: eval,
    degrees: degrees,
    sensor_id: sensor_id,
  ))
}

pub fn decode_temperature_response(
  data: BitArray,
) -> Result(TemperatureResponse, List(decode.DecodeError)) {
  decode.run(data, temperature_response_decoder())
}

pub fn search_temperatures_request_decoder() -> decode.Decoder(
  SearchTemperaturesRequest,
) {
  use min_degrees <- decode.then(decode.int32_with_default(1, 0))
  use max_degrees <- decode.then(decode.int32_with_default(2, 0))
  use location <- decode.then(decode.string_with_default(3, ""))
  decode.success(SearchTemperaturesRequest(
    min_degrees: min_degrees,
    max_degrees: max_degrees,
    location: location,
  ))
}

pub fn decode_search_temperatures_request(
  data: BitArray,
) -> Result(SearchTemperaturesRequest, List(decode.DecodeError)) {
  decode.run(data, search_temperatures_request_decoder())
}

pub fn list_temperatures_request_decoder() -> decode.Decoder(
  ListTemperaturesRequest,
) {
  use location <- decode.then(decode.string_with_default(1, ""))
  use limit <- decode.then(decode.int32_with_default(2, 0))
  use offset <- decode.then(decode.int32_with_default(3, 0))
  decode.success(ListTemperaturesRequest(
    location: location,
    limit: limit,
    offset: offset,
  ))
}

pub fn decode_list_temperatures_request(
  data: BitArray,
) -> Result(ListTemperaturesRequest, List(decode.DecodeError)) {
  decode.run(data, list_temperatures_request_decoder())
}

pub fn delete_temperature_request_decoder() -> decode.Decoder(
  DeleteTemperatureRequest,
) {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  decode.success(DeleteTemperatureRequest(
    sensor_id: sensor_id,
    location: location,
  ))
}

pub fn decode_delete_temperature_request(
  data: BitArray,
) -> Result(DeleteTemperatureRequest, List(decode.DecodeError)) {
  decode.run(data, delete_temperature_request_decoder())
}

pub fn update_temperature_request_decoder() -> decode.Decoder(
  UpdateTemperatureRequest,
) {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use unit <- decode.then(decode.string_with_default(3, ""))
  use notes <- decode.then(decode.string_with_default(4, ""))
  decode.success(UpdateTemperatureRequest(
    sensor_id: sensor_id,
    degrees: degrees,
    unit: unit,
    notes: notes,
  ))
}

pub fn decode_update_temperature_request(
  data: BitArray,
) -> Result(UpdateTemperatureRequest, List(decode.DecodeError)) {
  decode.run(data, update_temperature_request_decoder())
}

pub fn create_temperature_request_decoder() -> decode.Decoder(
  CreateTemperatureRequest,
) {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use degrees <- decode.then(decode.int32_with_default(2, 0))
  use unit <- decode.then(decode.string_with_default(3, ""))
  use location <- decode.then(decode.string_with_default(4, ""))
  decode.success(CreateTemperatureRequest(
    sensor_id: sensor_id,
    degrees: degrees,
    unit: unit,
    location: location,
  ))
}

pub fn decode_create_temperature_request(
  data: BitArray,
) -> Result(CreateTemperatureRequest, List(decode.DecodeError)) {
  decode.run(data, create_temperature_request_decoder())
}

pub fn get_temperature_request_decoder() -> decode.Decoder(
  GetTemperatureRequest,
) {
  use sensor_id <- decode.then(decode.string_with_default(1, ""))
  use location <- decode.then(decode.string_with_default(2, ""))
  use include_history <- decode.then(decode.bool_with_default(3, False))
  decode.success(GetTemperatureRequest(
    sensor_id: sensor_id,
    location: location,
    include_history: include_history,
  ))
}

pub fn decode_get_temperature_request(
  data: BitArray,
) -> Result(GetTemperatureRequest, List(decode.DecodeError)) {
  decode.run(data, get_temperature_request_decoder())
}

// Service: TemperatureService

/// Error type for TemperatureService service
pub type TemperatureServiceError {
  NotFound
  Unauthorized
  BadRequest(String)
  InvalidRequest(String)
  InternalError(String)
  Unavailable(String)
}

/// Auto-generated service for TemperatureService
/// 
/// Layer 1: Core service functions (transport-agnostic)
/// Layer 2: HTTP adapters (works with gleam/http)
/// 
/// Error types support telemetry and logging
/// Service-level errors that can occur during request processing
/// These can be logged for telemetry before converting to HTTP responses
pub type ServiceError {
  /// Failed to decode the protobuf request
  DecodeError(String)
  /// Handler returned an error
  HandlerError(TemperatureServiceError)
}

/// Service function for GetTemperature
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn get_temperature_service(
  request_bytes: BitArray,
  handler: fn(GetTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: get_temperature_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode GetTemperatureRequest"))
  }
}

/// Service function for CreateTemperature
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn create_temperature_service(
  request_bytes: BitArray,
  handler: fn(CreateTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: create_temperature_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode CreateTemperatureRequest"))
  }
}

/// Service function for UpdateTemperature
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn update_temperature_service(
  request_bytes: BitArray,
  handler: fn(UpdateTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: update_temperature_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode UpdateTemperatureRequest"))
  }
}

/// Service function for DeleteTemperature
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn delete_temperature_service(
  request_bytes: BitArray,
  handler: fn(DeleteTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: delete_temperature_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode DeleteTemperatureRequest"))
  }
}

/// Service function for ListTemperatures
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn list_temperatures_service(
  request_bytes: BitArray,
  handler: fn(ListTemperaturesRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: list_temperatures_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode ListTemperaturesRequest"))
  }
}

/// Service function for SearchTemperatures
/// Handles protobuf encoding/decoding, returns encoded response or error
pub fn search_temperatures_service(
  request_bytes: BitArray,
  handler: fn(SearchTemperaturesRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
) -> Result(BitArray, ServiceError) {
  case decode.run(request_bytes, with: search_temperatures_request_decoder()) {
    Ok(proto_request) -> {
      case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(HandlerError(err))
      }
    }
    Error(_) -> Error(DecodeError("Failed to decode SearchTemperaturesRequest"))
  }
}

/// HTTP adapter for GetTemperature
/// GET /v1/sensors/{sensor_id}/temperatures
/// Uses gleam/http types (server-agnostic)
pub fn http_get_temperature(
  req: request.Request(BitArray),
  handler: fn(GetTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  // Extract request from query/path parameters
  case format_query_request_for_get_temperature(req) {
    Ok(proto_request) -> {
      // Encode the request to bytes for the service function
      let request_bytes = encode_get_temperature_request(proto_request)
      case get_temperature_service(request_bytes, handler) {
        Ok(response_bytes) -> {
          response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          )
        }
        Error(service_error) -> {
          error_logger(service_error)
          service_error_to_http_response(service_error)
        }
      }
    }
    Error(_) -> {
      let err = DecodeError("Failed to parse query parameters")
      error_logger(err)
      service_error_to_http_response(err)
    }
  }
}

/// HTTP adapter for CreateTemperature
/// POST /v1/temperatures
/// Uses gleam/http types (server-agnostic)
pub fn http_create_temperature(
  req: request.Request(BitArray),
  handler: fn(CreateTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  let request_bytes = req.body
  case create_temperature_service(request_bytes, handler) {
    Ok(response_bytes) -> {
      response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      )
    }
    Error(service_error) -> {
      error_logger(service_error)
      service_error_to_http_response(service_error)
    }
  }
}

/// HTTP adapter for UpdateTemperature
/// PUT /v1/sensors/{sensor_id}/temperatures
/// Uses gleam/http types (server-agnostic)
pub fn http_update_temperature(
  req: request.Request(BitArray),
  handler: fn(UpdateTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  let request_bytes = req.body
  case update_temperature_service(request_bytes, handler) {
    Ok(response_bytes) -> {
      response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      )
    }
    Error(service_error) -> {
      error_logger(service_error)
      service_error_to_http_response(service_error)
    }
  }
}

/// HTTP adapter for DeleteTemperature
/// DELETE /v1/locations/{location}/sensors/{sensor_id}
/// Uses gleam/http types (server-agnostic)
pub fn http_delete_temperature(
  req: request.Request(BitArray),
  handler: fn(DeleteTemperatureRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  // Extract request from query/path parameters
  case format_query_request_for_delete_temperature(req) {
    Ok(proto_request) -> {
      // Encode the request to bytes for the service function
      let request_bytes = encode_delete_temperature_request(proto_request)
      case delete_temperature_service(request_bytes, handler) {
        Ok(response_bytes) -> {
          response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          )
        }
        Error(service_error) -> {
          error_logger(service_error)
          service_error_to_http_response(service_error)
        }
      }
    }
    Error(_) -> {
      let err = DecodeError("Failed to parse query parameters")
      error_logger(err)
      service_error_to_http_response(err)
    }
  }
}

/// HTTP adapter for ListTemperatures
/// GET /v1/temperatures
/// Uses gleam/http types (server-agnostic)
pub fn http_list_temperatures(
  req: request.Request(BitArray),
  handler: fn(ListTemperaturesRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  // Extract request from query/path parameters
  case format_query_request_for_list_temperatures(req) {
    Ok(proto_request) -> {
      // Encode the request to bytes for the service function
      let request_bytes = encode_list_temperatures_request(proto_request)
      case list_temperatures_service(request_bytes, handler) {
        Ok(response_bytes) -> {
          response.Response(
            status: 200,
            headers: [#("content-type", "application/x-protobuf")],
            body: response_bytes,
          )
        }
        Error(service_error) -> {
          error_logger(service_error)
          service_error_to_http_response(service_error)
        }
      }
    }
    Error(_) -> {
      let err = DecodeError("Failed to parse query parameters")
      error_logger(err)
      service_error_to_http_response(err)
    }
  }
}

/// HTTP adapter for SearchTemperatures
/// PATCH /v1/temperatures/search
/// Uses gleam/http types (server-agnostic)
pub fn http_search_temperatures(
  req: request.Request(BitArray),
  handler: fn(SearchTemperaturesRequest) ->
    Result(TemperatureResponse, TemperatureServiceError),
  error_logger: fn(ServiceError) -> Nil,
) -> response.Response(BitArray) {
  let request_bytes = req.body
  case search_temperatures_service(request_bytes, handler) {
    Ok(response_bytes) -> {
      response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      )
    }
    Error(service_error) -> {
      error_logger(service_error)
      service_error_to_http_response(service_error)
    }
  }
}

/// Convert ServiceError to HTTP response
/// This is used by the HTTP adapter layer
fn service_error_to_http_response(
  error: ServiceError,
) -> response.Response(BitArray) {
  case error {
    DecodeError(msg) ->
      response.Response(
        status: 400,
        headers: [#("content-type", "text/plain")],
        body: <<"Bad Request: ", msg:utf8>>,
      )
    HandlerError(handler_err) -> handler_error_to_http_response(handler_err)
  }
}

/// Convert handler-specific errors to HTTP responses
fn handler_error_to_http_response(
  error: TemperatureServiceError,
) -> response.Response(BitArray) {
  case error {
    NotFound ->
      response.Response(
        status: 404,
        headers: [#("content-type", "text/plain")],
        body: <<"Not Found":utf8>>,
      )
    Unauthorized ->
      response.Response(
        status: 401,
        headers: [
          #("content-type", "text/plain"),
          #("www-authenticate", "Bearer"),
        ],
        body: <<"Unauthorized":utf8>>,
      )
    BadRequest(msg) ->
      response.Response(
        status: 400,
        headers: [#("content-type", "text/plain")],
        body: <<"Bad Request: ", msg:utf8>>,
      )
    InvalidRequest(msg) ->
      response.Response(
        status: 400,
        headers: [#("content-type", "text/plain")],
        body: <<"Invalid Request: ", msg:utf8>>,
      )
    InternalError(msg) ->
      response.Response(
        status: 500,
        headers: [#("content-type", "text/plain")],
        body: <<"Internal Error: ", msg:utf8>>,
      )
    Unavailable(msg) ->
      response.Response(
        status: 503,
        headers: [#("content-type", "text/plain"), #("retry-after", "60")],
        body: <<"Service Unavailable: ", msg:utf8>>,
      )
  }
}

/// Map query parameters to GetTemperatureRequest
fn format_query_request_for_get_temperature(
  req: request.Request(BitArray),
) -> Result(GetTemperatureRequest, Nil) {
  // Extract path parameters from request path
  let path_params =
    extract_path_params_from_request(
      req.path,
      "/v1/sensors/{sensor_id}/temperatures",
    )
  case request.get_query(req) {
    Ok(params) -> {
      // Extract and convert each field from parsed query params
      let sensor_id = get_path_param_string(path_params, "sensor_id", "")
      let location = get_query_param_string(params, "location", "")
      let include_history =
        get_query_param_bool(params, "include_history", False)

      Ok(GetTemperatureRequest(
        sensor_id: sensor_id,
        location: location,
        include_history: include_history,
      ))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: get_temperature_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Map query parameters to DeleteTemperatureRequest
fn format_query_request_for_delete_temperature(
  req: request.Request(BitArray),
) -> Result(DeleteTemperatureRequest, Nil) {
  // Extract path parameters from request path
  let path_params =
    extract_path_params_from_request(
      req.path,
      "/v1/locations/{location}/sensors/{sensor_id}",
    )
  case request.get_query(req) {
    Ok(_params) -> {
      // Extract and convert each field from parsed query params
      let sensor_id = get_path_param_string(path_params, "sensor_id", "")
      let location = get_path_param_string(path_params, "location", "")

      Ok(DeleteTemperatureRequest(sensor_id: sensor_id, location: location))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: delete_temperature_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Map query parameters to ListTemperaturesRequest
fn format_query_request_for_list_temperatures(
  req: request.Request(BitArray),
) -> Result(ListTemperaturesRequest, Nil) {
  case request.get_query(req) {
    Ok(params) -> {
      // Extract and convert each field from parsed query params
      let location = get_query_param_string(params, "location", "")
      let limit = get_query_param_int(params, "limit", 0)
      let offset = get_query_param_int(params, "offset", 0)

      Ok(ListTemperaturesRequest(
        location: location,
        limit: limit,
        offset: offset,
      ))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: list_temperatures_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Extract path parameters from request path based on pattern
/// Example: extract_path_params_from_request("/v1/temperatures/123", "/v1/temperatures/{id}")
///   returns [("id", "123")]
fn extract_path_params_from_request(
  path: String,
  pattern: String,
) -> List(#(String, String)) {
  let path_segments = string.split(path, "/") |> list.filter(fn(s) { s != "" })
  let pattern_segments =
    string.split(pattern, "/") |> list.filter(fn(s) { s != "" })
  extract_params_from_segments(path_segments, pattern_segments, [])
}

/// Helper to extract parameters by matching path segments with pattern segments
fn extract_params_from_segments(
  path_segments: List(String),
  pattern_segments: List(String),
  acc: List(#(String, String)),
) -> List(#(String, String)) {
  case path_segments, pattern_segments {
    [], _ -> list.reverse(acc)
    _, [] -> list.reverse(acc)
    [path_seg, ..path_rest], [pattern_seg, ..pattern_rest] -> {
      case
        string.starts_with(pattern_seg, "{")
        && string.ends_with(pattern_seg, "}")
      {
        True -> {
          // This is a path parameter
          let param_name =
            string.slice(pattern_seg, 1, string.length(pattern_seg) - 2)
            |> string.lowercase
          extract_params_from_segments(path_rest, pattern_rest, [
            #(param_name, path_seg),
            ..acc
          ])
        }
        False -> {
          // This is a literal segment, skip
          extract_params_from_segments(path_rest, pattern_rest, acc)
        }
      }
    }
  }
}

/// Get path parameter as string with default
fn get_path_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}

/// Get string query parameter with default
fn get_query_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}

/// Get int query parameter with default
fn get_query_param_int(
  params: List(#(String, String)),
  key: String,
  default: Int,
) -> Int {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case int.parse(value) {
        Ok(i) -> i
        Error(_) -> default
      }
    }
    Error(_) -> default
  }
}

/// Get bool query parameter with default
fn get_query_param_bool(
  params: List(#(String, String)),
  key: String,
  default: Bool,
) -> Bool {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case string.lowercase(value) {
        "true" | "1" | "yes" -> True
        "false" | "0" | "no" -> False
        _ -> default
      }
    }
    Error(_) -> default
  }
}
