//// Generated by Protozoa from nested.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/list
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type NestedOuterInner {
  NestedOuterInner(
    value: String,
  )
}

pub type NestedOuter {
  NestedOuter(
    inner: NestedOuterInner,
    items: List(NestedOuterInner),
  )
}

pub type NestedContainer {
  NestedContainer(
    nested_inner: NestedOuterInner,
  )
}

pub fn encode_nested_container(nested_container: NestedContainer) -> BitArray {
  encode.message([
    encode.field(1, wire.LengthDelimited, encode.length_delimited(encode_nested_outer_inner(nested_container.nested_inner))),
  ])
}

pub fn encode_nested_outer(nested_outer: NestedOuter) -> BitArray {
  let items_fields = list.map(nested_outer.items, fn(v) { encode.field(2, wire.LengthDelimited, encode.length_delimited(encode_nested_outer_inner(v))) })
  encode.message(list.flatten([items_fields, [encode.field(1, wire.LengthDelimited, encode.length_delimited(encode_nested_outer_inner(nested_outer.inner)))]]))
}

pub fn encode_nested_outer_inner(nested_outer_inner: NestedOuterInner) -> BitArray {
  encode.message([
    encode.string_field(1, nested_outer_inner.value),
  ])
}

pub fn nested_container_decoder() -> decode.Decoder(NestedContainer) {
  use nested_inner <- decode.then(decode.nested_message(1, nested_outer_inner_decoder()))
  decode.success(NestedContainer(nested_inner: nested_inner))
}

pub fn decode_nested_container(data: BitArray) -> Result(NestedContainer, List(decode.DecodeError)) {
  decode.run(data, nested_container_decoder())
}

pub fn nested_outer_decoder() -> decode.Decoder(NestedOuter) {
  use inner <- decode.then(decode.nested_message(1, nested_outer_inner_decoder()))
  use items <- decode.then(decode.repeated_field(2, fn(field) { decode.message_field(_, nested_outer_inner_decoder())(field) }))
  decode.success(NestedOuter(inner: inner, items: items))
}

pub fn decode_nested_outer(data: BitArray) -> Result(NestedOuter, List(decode.DecodeError)) {
  decode.run(data, nested_outer_decoder())
}

pub fn nested_outer_inner_decoder() -> decode.Decoder(NestedOuterInner) {
  use value <- decode.then(decode.string_with_default(1, ""))
  decode.success(NestedOuterInner(value: value))
}

pub fn decode_nested_outer_inner(data: BitArray) -> Result(NestedOuterInner, List(decode.DecodeError)) {
  decode.run(data, nested_outer_inner_decoder())
}