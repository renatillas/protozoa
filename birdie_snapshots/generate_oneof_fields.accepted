---
version: 1.4.0
title: Generate oneof fields
file: ./test/codegen_test.gleam
test_name: generate_oneof_code_test
---
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/result
import gloto/decode
import gloto/encode



pub type TestOneofTestValue {
  StringValue(String)
  IntValue(Int)
}

pub type TestOneof {
  TestOneof(
  name: String,
  id: Int,
  test_value: Result(TestOneofTestValue, Nil)
  )
}

pub fn encode_testoneof(testoneof: TestOneof) -> BitArray {
  encode.message([
    encode.string_field(1, testoneof.name),
    encode.int32_field(10, testoneof.id),
    case testoneof.test_value {
    Ok(oneof_value) -> {
      case oneof_value {
      StringValue(value) -> encode.string_field(2, value)
      IntValue(value) -> encode.int32_field(3, value)
      }
    }
    Error(_) -> <<>>
  }
  ])
}

pub fn testoneof_decoder() -> decode.Decoder(TestOneof) {
  use name <- decode.subrecord(decode.string_with_default(1, ""))
  use id <- decode.subrecord(decode.int32_with_default(10, 0))
  use test_value <- decode.subrecord(oneof_test_value_decoder())
  decode.success(TestOneof(name: name, id: id, test_value: test_value))
}

pub fn decode_testoneof(data: BitArray) -> Result(TestOneof, decode.DecodeError) {
  decode.decode(data, testoneof_decoder())
}

fn oneof_test_value_decoder() -> decode.Decoder(Result(TestOneofTestValue, Nil)) {
  fn(fields) {
    case list.find(fields, fn(f) { f.number == 2 }) {
      Ok(field) -> {
        case decode.string_field(field) {
          Ok(value) -> Ok(Ok(TestOneofTestValue.StringValue(value)))
          Error(_) -> {
            case list.find(fields, fn(f) { f.number == 3 }) {
              Ok(field) -> {
                case decode.int32_field(field) {
                  Ok(value) -> Ok(Ok(TestOneofTestValue.IntValue(value)))
                  Error(_) -> Ok(Error(Nil))
                }
              }
              Error(_) -> Ok(Error(Nil))
            }
          }
        }
      }
      Error(_) -> {
        case list.find(fields, fn(f) { f.number == 3 }) {
          Ok(field) -> {
            case decode.int32_field(field) {
              Ok(value) -> Ok(Ok(TestOneofTestValue.IntValue(value)))
              Error(_) -> Ok(Error(Nil))
            }
          }
          Error(_) -> Ok(Error(Nil))
        }
      }
    }
  }
  |> decode.Decoder
}


