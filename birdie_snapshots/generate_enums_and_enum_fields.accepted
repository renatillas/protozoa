---
version: 1.4.0
title: Generate enums and enum fields
file: ./test/codegen_test.gleam
test_name: generate_enums_test
---
import gleam/list
import gloto/wire
import gloto/decode
import gloto/encode

pub type Status {
  UNKNOWN
  PENDING
  ACTIVE
  COMPLETED
}

pub type Task {
  Task(
  id: String,
  status: Status,
  history: List(Status)
  )
}

pub fn encode_task(task: Task) -> BitArray {
  let history_fields = list.map(task.history, fn(v) { encode.int32_field(3, encode_status_value(v)) })
  let other_fields = [
    encode.string_field(1, task.id),
    encode.int32_field(2, encode_status_value(task.status))
  ]
  encode.message(list.append(other_fields, list.flatten([history_fields])))
}

pub fn task_decoder() -> decode.Decoder(Task) {
  use id <- decode.subrecord(decode.string_with_default(1, ""))
  use status <- decode.subrecord(decode_status_field(2))
  use history <- decode.subrecord(decode_repeated_status(3))
  decode.success(Task(id: id, status: status, history: history))
}

pub fn decode_task(data: BitArray) -> Result(Task, decode.DecodeError) {
  decode.decode(data, task_decoder())
}

pub fn encode_status_value(value: Status) -> Int {
  case value {
    UNKNOWN -> 0
    PENDING -> 1
    ACTIVE -> 2
    COMPLETED -> 3
  }
}

pub fn decode_status_value(value: Int) -> Result(Status, String) {
  case value {
    0 -> Ok(UNKNOWN)
    1 -> Ok(PENDING)
    2 -> Ok(ACTIVE)
    3 -> Ok(COMPLETED)
    _ -> Error("Unknown enum value: " <> int.to_string(value))
  }
}

pub fn decode_status_field(field_num: Int) -> decode.Decoder(Status) {
  decode.field(field_num, fn(f) {
    use value <- result.try(decode.varint_field(f))
    decode_status_value(value)
    |> result.map_error(fn(e) { decode.DecodeError(e) })
  })
}

pub fn decode_repeated_status(field_num: Int) -> decode.Decoder(List(Status)) {
  decode.repeated_field(field_num, fn(f) {
    use value <- result.try(decode.varint_field(f))
    decode_status_value(value)
    |> result.map_error(fn(e) { decode.DecodeError(e) })
  })
}
