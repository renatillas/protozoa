---
version: 1.4.0
title: Generate message with multiple oneofs
file: ./test/codegen_test.gleam
test_name: generate_multiple_oneofs_test
---
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/result
import gloto/decode
import gloto/encode



pub type MultipleOneofsFirstChoice {
  OptionA(String)
  OptionB(Int)
}

pub type MultipleOneofsSecondChoice {
  Enabled(Bool)
  Value(Float)
}

pub type MultipleOneofs {
  MultipleOneofs(
  id: String,
  name: String,
  first_choice: Result(MultipleOneofsFirstChoice, Nil),
  second_choice: Result(MultipleOneofsSecondChoice, Nil)
  )
}

pub fn encode_multipleoneofs(multipleoneofs: MultipleOneofs) -> BitArray {
  encode.message([
    encode.string_field(1, multipleoneofs.id),
    encode.string_field(10, multipleoneofs.name),
    case multipleoneofs.first_choice {
    Ok(oneof_value) -> {
      case oneof_value {
      OptionA(value) -> encode.string_field(2, value)
      OptionB(value) -> encode.int32_field(3, value)
      }
    }
    Error(_) -> <<>>
  },
    case multipleoneofs.second_choice {
    Ok(oneof_value) -> {
      case oneof_value {
      Enabled(value) -> encode.bool_field(4, value)
      Value(value) -> encode.float_field(5, value)
      }
    }
    Error(_) -> <<>>
  }
  ])
}

pub fn multipleoneofs_decoder() -> decode.Decoder(MultipleOneofs) {
  use id <- decode.subrecord(decode.string_with_default(1, ""))
  use name <- decode.subrecord(decode.string_with_default(10, ""))
  use first_choice <- decode.subrecord(oneof_first_choice_decoder())
  use second_choice <- decode.subrecord(oneof_second_choice_decoder())
  decode.success(MultipleOneofs(id: id, name: name, first_choice: first_choice, second_choice: second_choice))
}

pub fn decode_multipleoneofs(data: BitArray) -> Result(MultipleOneofs, decode.DecodeError) {
  decode.decode(data, multipleoneofs_decoder())
}

fn oneof_first_choice_decoder() -> decode.Decoder(Result(MultipleOneofsFirstChoice, Nil)) {
  fn(fields) {
    case list.find(fields, fn(f) { f.number == 2 }) {
      Ok(field) -> {
        case decode.string_field(field) {
          Ok(value) -> Ok(Ok(MultipleOneofsFirstChoice.OptionA(value)))
          Error(_) -> {
            case list.find(fields, fn(f) { f.number == 3 }) {
              Ok(field) -> {
                case decode.int32_field(field) {
                  Ok(value) -> Ok(Ok(MultipleOneofsFirstChoice.OptionB(value)))
                  Error(_) -> Ok(Error(Nil))
                }
              }
              Error(_) -> Ok(Error(Nil))
            }
          }
        }
      }
      Error(_) -> {
        case list.find(fields, fn(f) { f.number == 3 }) {
          Ok(field) -> {
            case decode.int32_field(field) {
              Ok(value) -> Ok(Ok(MultipleOneofsFirstChoice.OptionB(value)))
              Error(_) -> Ok(Error(Nil))
            }
          }
          Error(_) -> Ok(Error(Nil))
        }
      }
    }
  }
  |> decode.Decoder
}

fn oneof_second_choice_decoder() -> decode.Decoder(Result(MultipleOneofsSecondChoice, Nil)) {
  fn(fields) {
    case list.find(fields, fn(f) { f.number == 4 }) {
      Ok(field) -> {
        case decode.bool_field(field) {
          Ok(value) -> Ok(Ok(MultipleOneofsSecondChoice.Enabled(value)))
          Error(_) -> {
            case list.find(fields, fn(f) { f.number == 5 }) {
              Ok(field) -> {
                case decode.float_field(field) {
                  Ok(value) -> Ok(Ok(MultipleOneofsSecondChoice.Value(value)))
                  Error(_) -> Ok(Error(Nil))
                }
              }
              Error(_) -> Ok(Error(Nil))
            }
          }
        }
      }
      Error(_) -> {
        case list.find(fields, fn(f) { f.number == 5 }) {
          Ok(field) -> {
            case decode.float_field(field) {
              Ok(value) -> Ok(Ok(MultipleOneofsSecondChoice.Value(value)))
              Error(_) -> Ok(Error(Nil))
            }
          }
          Error(_) -> Ok(Error(Nil))
        }
      }
    }
  }
  |> decode.Decoder
}


