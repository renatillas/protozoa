---
version: 1.4.1
title: HTTP service with query parameter mapping
---
//// Generated by Protozoa from test/test_http_service.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m protozoa
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/bytes_tree
import gleam/float
import gleam/http
import gleam/http/request
import gleam/http/response
import gleam/int
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/string
import mist
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type TemperatureRequest {
  TemperatureRequest(
    id: Int,
    celsius: Int,
    location: String,
    use_cache: Bool,
    precision: Float,
  )
}

pub type TemperatureResponse {
  TemperatureResponse(
    fahrenheit: Int,
    message: String,
  )
}

pub type DeleteRequest {
  DeleteRequest(
    id: Int,
  )
}

pub type DeleteResponse {
  DeleteResponse(
    success: Bool,
    message: String,
  )
}

pub type ListRequest {
  ListRequest(
    limit: Int,
    offset: Int,
  )
}

pub type ListResponse {
  ListResponse(
    temperatures: List(TemperatureResponse),
    total: Int,
  )
}

pub fn encode_list_response(list_response: ListResponse) -> BitArray {
  let temperatures_fields = list.map(list_response.temperatures, fn(v) { encode.field(1, wire.LengthDelimited, encode.length_delimited(encode_temperature_response(v))) })
  encode.message(list.flatten([temperatures_fields, [encode.int32_field(2, list_response.total)]]))
}

pub fn encode_list_request(list_request: ListRequest) -> BitArray {
  encode.message([
    encode.int32_field(1, list_request.limit),
    encode.int32_field(2, list_request.offset),
  ])
}

pub fn encode_delete_response(delete_response: DeleteResponse) -> BitArray {
  encode.message([
    encode.bool_field(1, delete_response.success),
    encode.string_field(2, delete_response.message),
  ])
}

pub fn encode_delete_request(delete_request: DeleteRequest) -> BitArray {
  encode.message([
    encode.int32_field(1, delete_request.id),
  ])
}

pub fn encode_temperature_response(temperature_response: TemperatureResponse) -> BitArray {
  encode.message([
    encode.int32_field(1, temperature_response.fahrenheit),
    encode.string_field(2, temperature_response.message),
  ])
}

pub fn encode_temperature_request(temperature_request: TemperatureRequest) -> BitArray {
  encode.message([
    encode.int32_field(1, temperature_request.id),
    encode.int32_field(2, temperature_request.celsius),
    encode.string_field(3, temperature_request.location),
    encode.bool_field(4, temperature_request.use_cache),
    encode.float_field(5, temperature_request.precision),
  ])
}

pub fn list_response_decoder() -> decode.Decoder(ListResponse) {
  use temperatures <- decode.then(decode.repeated_field(1, fn(field) { decode.message_field(_, temperature_response_decoder())(field) }))
  use total <- decode.then(decode.int32_with_default(2, 0))
  decode.success(ListResponse(temperatures: temperatures, total: total))
}

pub fn decode_list_response(data: BitArray) -> Result(ListResponse, List(decode.DecodeError)) {
  decode.run(data, list_response_decoder())
}

pub fn list_request_decoder() -> decode.Decoder(ListRequest) {
  use limit <- decode.then(decode.int32_with_default(1, 0))
  use offset <- decode.then(decode.int32_with_default(2, 0))
  decode.success(ListRequest(limit: limit, offset: offset))
}

pub fn decode_list_request(data: BitArray) -> Result(ListRequest, List(decode.DecodeError)) {
  decode.run(data, list_request_decoder())
}

pub fn delete_response_decoder() -> decode.Decoder(DeleteResponse) {
  use success <- decode.then(decode.bool_with_default(1, False))
  use message <- decode.then(decode.string_with_default(2, ""))
  decode.success(DeleteResponse(success: success, message: message))
}

pub fn decode_delete_response(data: BitArray) -> Result(DeleteResponse, List(decode.DecodeError)) {
  decode.run(data, delete_response_decoder())
}

pub fn delete_request_decoder() -> decode.Decoder(DeleteRequest) {
  use id <- decode.then(decode.int32_with_default(1, 0))
  decode.success(DeleteRequest(id: id))
}

pub fn decode_delete_request(data: BitArray) -> Result(DeleteRequest, List(decode.DecodeError)) {
  decode.run(data, delete_request_decoder())
}

pub fn temperature_response_decoder() -> decode.Decoder(TemperatureResponse) {
  use fahrenheit <- decode.then(decode.int32_with_default(1, 0))
  use message <- decode.then(decode.string_with_default(2, ""))
  decode.success(TemperatureResponse(fahrenheit: fahrenheit, message: message))
}

pub fn decode_temperature_response(data: BitArray) -> Result(TemperatureResponse, List(decode.DecodeError)) {
  decode.run(data, temperature_response_decoder())
}

pub fn temperature_request_decoder() -> decode.Decoder(TemperatureRequest) {
  use id <- decode.then(decode.int32_with_default(1, 0))
  use celsius <- decode.then(decode.int32_with_default(2, 0))
  use location <- decode.then(decode.string_with_default(3, ""))
  use use_cache <- decode.then(decode.bool_with_default(4, False))
  use precision <- decode.then(decode.float(5))
  decode.success(TemperatureRequest(
    id: id,
    celsius: celsius,
    location: location,
    use_cache: use_cache,
    precision: precision,
  ))
}

pub fn decode_temperature_request(data: BitArray) -> Result(TemperatureRequest, List(decode.DecodeError)) {
  decode.run(data, temperature_request_decoder())
}

// Service: TemperatureService

/// Error type for TemperatureService service
pub type TemperatureServiceError {
  NotFound
  Unauthorized
  BadRequest(String)
  InvalidRequest(String)
  InternalError(String)
  Unavailable(String)
}

/// Auto-generated service setup for TemperatureService
/// Register these handlers with your Mist application

/// HTTP GET /v1/temperatures/{id}
/// Accepts a handler function that processes the request
pub fn http_get_temperature(
  req: request.Request(BitArray),
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) -> response.Response(mist.ResponseData) {
  case req.method {
    http.Get -> {
      case format_query_request_for_get_temperature(req) {
        Ok(proto_request) -> {
          case handler(proto_request) {
            Ok(response) -> {
              response.new(200)
              |> response.set_body(mist.Bytes(bytes_tree.from_bit_array(encode_temperature_response(response))))
            }
            Error(err) -> format_error_response(err)
          }
        }
        Error(_) -> {
          response.new(400)
          |> response.set_body(mist.Bytes(bytes_tree.from_string("Invalid request")))
        }
      }
    }
    _ -> {
      response.new(405)
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Method not allowed")))
    }
  }
}

/// HTTP DELETE /v1/temperatures/{id}
/// Accepts a handler function that processes the request
pub fn http_delete_temperature(
  req: request.Request(BitArray),
  handler: fn(DeleteRequest) -> Result(DeleteResponse, TemperatureServiceError),
) -> response.Response(mist.ResponseData) {
  case req.method {
    http.Delete -> {
      case format_query_request_for_delete_temperature(req) {
        Ok(proto_request) -> {
          case handler(proto_request) {
            Ok(response) -> {
              response.new(200)
              |> response.set_body(mist.Bytes(bytes_tree.from_bit_array(encode_delete_response(response))))
            }
            Error(err) -> format_error_response(err)
          }
        }
        Error(_) -> {
          response.new(400)
          |> response.set_body(mist.Bytes(bytes_tree.from_string("Invalid request")))
        }
      }
    }
    _ -> {
      response.new(405)
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Method not allowed")))
    }
  }
}

/// HTTP POST /v1/temperatures
/// Accepts a handler function that processes the request
pub fn http_create_temperature(
  req: request.Request(BitArray),
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) -> response.Response(mist.ResponseData) {
  case req.method {
    http.Post -> {
      case decode.run(req.body, with: temperature_request_decoder()) {
        Ok(proto_request) -> {
          case handler(proto_request) {
            Ok(response) -> {
              response.new(200)
              |> response.set_body(mist.Bytes(bytes_tree.from_bit_array(encode_temperature_response(response))))
            }
            Error(err) -> format_error_response(err)
          }
        }
        Error(_) -> {
          response.new(400)
          |> response.set_body(mist.Bytes(bytes_tree.from_string("Invalid request body")))
        }
      }
    }
    _ -> {
      response.new(405)
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Method not allowed")))
    }
  }
}

/// HTTP GET /v1/temperatures
/// Accepts a handler function that processes the request
pub fn http_list_temperatures(
  req: request.Request(BitArray),
  handler: fn(ListRequest) -> Result(ListResponse, TemperatureServiceError),
) -> response.Response(mist.ResponseData) {
  case req.method {
    http.Get -> {
      case format_query_request_for_list_temperatures(req) {
        Ok(proto_request) -> {
          case handler(proto_request) {
            Ok(response) -> {
              response.new(200)
              |> response.set_body(mist.Bytes(bytes_tree.from_bit_array(encode_list_response(response))))
            }
            Error(err) -> format_error_response(err)
          }
        }
        Error(_) -> {
          response.new(400)
          |> response.set_body(mist.Bytes(bytes_tree.from_string("Invalid request")))
        }
      }
    }
    _ -> {
      response.new(405)
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Method not allowed")))
    }
  }
}

/// Format service errors as HTTP responses using standard HTTP status codes
fn format_error_response(error: TemperatureServiceError) -> response.Response(mist.ResponseData) {
  case error {
    NotFound ->
      response.new(404)
      |> response.prepend_header("content-type", "text/plain")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Not Found")))
    Unauthorized ->
      response.new(401)
      |> response.prepend_header("content-type", "text/plain")
      |> response.prepend_header("www-authenticate", "Bearer")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Unauthorized")))
    BadRequest(msg) ->
      response.new(400)
      |> response.prepend_header("content-type", "text/plain")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Bad Request: " <> msg)))
    InvalidRequest(msg) ->
      response.new(400)
      |> response.prepend_header("content-type", "text/plain")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Invalid Request: " <> msg)))
    InternalError(msg) ->
      response.new(500)
      |> response.prepend_header("content-type", "text/plain")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Internal Error: " <> msg)))
    Unavailable(msg) ->
      response.new(503)
      |> response.prepend_header("content-type", "text/plain")
      |> response.prepend_header("retry-after", "60")
      |> response.set_body(mist.Bytes(bytes_tree.from_string("Service Unavailable: " <> msg)))
  }
}

/// Map query parameters to TemperatureRequest
fn format_query_request_for_get_temperature(req: request.Request(BitArray)) -> Result(TemperatureRequest, Nil) {
  // Extract path parameters from request path
  let path_params = extract_path_params_from_request(req.path, "/v1/temperatures/{id}")
  case request.get_query(req) {
    Ok(params) -> {
      // Extract and convert each field from parsed query params
      let id = get_path_param_int(path_params, "id", 0)
  let celsius = get_query_param_int(params, "celsius", 0)
  let location = get_query_param_string(params, "location", "")
  let use_cache = get_query_param_bool(params, "use_cache", False)
  let precision = get_query_param_float(params, "precision", 0.0)
      
      Ok(TemperatureRequest(id: id, celsius: celsius, location: location, use_cache: use_cache, precision: precision))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: temperature_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Map query parameters to DeleteRequest
fn format_query_request_for_delete_temperature(req: request.Request(BitArray)) -> Result(DeleteRequest, Nil) {
  // Extract path parameters from request path
  let path_params = extract_path_params_from_request(req.path, "/v1/temperatures/{id}")
  case request.get_query(req) {
    Ok(params) -> {
      // Extract and convert each field from parsed query params
      let id = get_path_param_int(path_params, "id", 0)
      
      Ok(DeleteRequest(id: id))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: delete_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Map query parameters to ListRequest
fn format_query_request_for_list_temperatures(req: request.Request(BitArray)) -> Result(ListRequest, Nil) {
  case request.get_query(req) {
    Ok(params) -> {
      // Extract and convert each field from parsed query params
      let limit = get_query_param_int(params, "limit", 0)
  let offset = get_query_param_int(params, "offset", 0)
      
      Ok(ListRequest(limit: limit, offset: offset))
    }
    Error(_) -> {
      // No query params, create message with defaults
      case decode.run(<<>>, with: list_request_decoder()) {
        Ok(msg) -> Ok(msg)
        Error(_) -> Error(Nil)
      }
    }
  }
}

/// Extract path parameters from request path based on pattern
/// Example: extract_path_params_from_request("/v1/temperatures/123", "/v1/temperatures/{id}")
///   returns [("id", "123")]
fn extract_path_params_from_request(path: String, pattern: String) -> List(#(String, String)) {
  let path_segments = string.split(path, "/") |> list.filter(fn(s) { s != "" })
  let pattern_segments = string.split(pattern, "/") |> list.filter(fn(s) { s != "" })
  extract_params_from_segments(path_segments, pattern_segments, [])
}

/// Helper to extract parameters by matching path segments with pattern segments
fn extract_params_from_segments(
  path_segments: List(String),
  pattern_segments: List(String),
  acc: List(#(String, String)),
) -> List(#(String, String)) {
  case path_segments, pattern_segments {
    [], _ -> list.reverse(acc)
    _, [] -> list.reverse(acc)
    [path_seg, ..path_rest], [pattern_seg, ..pattern_rest] -> {
      case string.starts_with(pattern_seg, "{") && string.ends_with(pattern_seg, "}") {
        True -> {
          // This is a path parameter
          let param_name = string.slice(pattern_seg, 1, string.length(pattern_seg) - 2) |> string.lowercase
          extract_params_from_segments(path_rest, pattern_rest, [#(param_name, path_seg), ..acc])
        }
        False -> {
          // This is a literal segment, skip
          extract_params_from_segments(path_rest, pattern_rest, acc)
        }
      }
    }
  }
}

/// Get path parameter as string with default
fn get_path_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}

/// Get path parameter as int with default
fn get_path_param_int(
  params: List(#(String, String)),
  key: String,
  default: Int,
) -> Int {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case int.parse(value) {
        Ok(i) -> i
        Error(_) -> default
      }
    }
    Error(_) -> default
  }
}

/// Get string query parameter with default
fn get_query_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}

/// Get int query parameter with default
fn get_query_param_int(
  params: List(#(String, String)),
  key: String,
  default: Int,
) -> Int {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case int.parse(value) {
        Ok(i) -> i
        Error(_) -> default
      }
    }
    Error(_) -> default
  }
}

/// Get bool query parameter with default
fn get_query_param_bool(
  params: List(#(String, String)),
  key: String,
  default: Bool,
) -> Bool {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case string.lowercase(value) {
        "true" | "1" | "yes" -> True
        "false" | "0" | "no" -> False
        _ -> default
      }
    }
    Error(_) -> default
  }
}

/// Get float query parameter with default
fn get_query_param_float(
  params: List(#(String, String)),
  key: String,
  default: Float,
) -> Float {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case float.parse(value) {
        Ok(f) -> f
        Error(_) -> default
      }
    }
    Error(_) -> default
  }
}

/// Get list of string query parameters
fn get_query_param_list_string(
  params: List(#(String, String)),
  key: String,
) -> List(String) {
  params
  |> list.filter(fn(p) { p.0 == key })
  |> list.map(fn(p) { p.1 })
}

/// Get list of int query parameters
fn get_query_param_list_int(
  params: List(#(String, String)),
  key: String,
) -> List(Int) {
  params
  |> list.filter(fn(p) { p.0 == key })
  |> list.filter_map(fn(p) { int.parse(p.1) })
}

/// Get optional string query parameter
fn get_query_param_optional_string(
  params: List(#(String, String)),
  key: String,
) -> option.Option(String) {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> option.Some(value)
    Error(_) -> option.None
  }
}

/// Get optional int query parameter
fn get_query_param_optional_int(
  params: List(#(String, String)),
  key: String,
) -> option.Option(Int) {
  case list.find(params, fn(p) { p.0 == key }) {
    Ok(#(_, value)) -> {
      case int.parse(value) {
        Ok(i) -> option.Some(i)
        Error(_) -> option.None
      }
    }
    Error(_) -> option.None
  }
}

/// Detect content type from request headers
fn detect_request_content_type(req: request.Request(BitArray)) -> String {
  case get_header(req, "content-type") {
    Ok(content_type) -> {
      case string.split(content_type, ";") {
        [main_type, ..] -> main_type
        [] -> "application/protobuf"
      }
    }
    Error(_) -> "application/protobuf"
  }
}

/// Negotiate response content type from Accept header
fn negotiate_response_content_type(req: request.Request(BitArray)) -> String {
  case get_header(req, "accept") {
    Ok(accept) -> {
      case string.contains(accept, "application/json") {
        True -> "application/json"
        False -> "application/protobuf"
      }
    }
    Error(_) -> "application/protobuf"
  }
}

/// Extract header value from request
fn get_header(req: request.Request(BitArray), key: String) -> Result(String, Nil) {
  case list.find(req.headers, fn(h) {
    let #(name, _) = h
    string.lowercase(name) == string.lowercase(key)
  }) {
    Ok(#(_, value)) -> Ok(value)
    Error(_) -> Error(Nil)
  }
}
