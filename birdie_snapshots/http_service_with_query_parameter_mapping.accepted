---
version: 1.5.1
title: HTTP service with query parameter mapping
file: ./test/router_query_params_test.gleam
test_name: query_parameter_mapping_test
---
//// Generated by Protozoa from test_http_service.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/float
import gleam/http/request
import gleam/http/response
import gleam/int
import gleam/list
import gleam/string
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type TemperatureRequest {
  TemperatureRequest(id: Int, celsius: Int, location: String, use_cache: Bool, precision: Float)
}



pub fn encode_temperature_request(temperature_request: TemperatureRequest) {
  encode.message(
    [
      encode.int32_field(1, temperature_request.id),
      encode.int32_field(2, temperature_request.celsius),
      encode.string_field(3, temperature_request.location),
      encode.bool_field(4, temperature_request.use_cache),
      encode.float_field(5, temperature_request.precision), 
    ],
  )
}



pub fn temperature_request_decoder() {
  use id <- decode.then(decode.int32_with_default(1, 0))
  use celsius <- decode.then(decode.int32_with_default(2, 0))
  use location <- decode.then(decode.string_with_default(3, ""))
  use use_cache <- decode.then(decode.bool_with_default(4, False))
  use precision <- decode.then(decode.float(5))
  decode.success(
    TemperatureRequest(
      id: id,
      celsius: celsius,
      location: location,
      use_cache: use_cache,
      precision: precision,
    ),
  )
}



pub fn decode_temperature_request(data: BitArray) {
  decode.run(data, temperature_request_decoder())
}



pub type TemperatureResponse {
  TemperatureResponse(fahrenheit: Int, message: String)
}



pub fn encode_temperature_response(temperature_response: TemperatureResponse) {
  encode.message(
    [
      encode.int32_field(1, temperature_response.fahrenheit),
      encode.string_field(2, temperature_response.message), 
    ],
  )
}



pub fn temperature_response_decoder() {
  use fahrenheit <- decode.then(decode.int32_with_default(1, 0))
  use message <- decode.then(decode.string_with_default(2, ""))
  decode.success(TemperatureResponse(fahrenheit: fahrenheit, message: message))
}



pub fn decode_temperature_response(data: BitArray) {
  decode.run(data, temperature_response_decoder())
}



pub type DeleteRequest {
  DeleteRequest(id: Int)
}



pub fn encode_delete_request(delete_request: DeleteRequest) {
  encode.message([encode.int32_field(1, delete_request.id)])
}



pub fn delete_request_decoder() {
  use id <- decode.then(decode.int32_with_default(1, 0))
  decode.success(DeleteRequest(id: id))
}



pub fn decode_delete_request(data: BitArray) {
  decode.run(data, delete_request_decoder())
}



pub type DeleteResponse {
  DeleteResponse(success: Bool, message: String)
}



pub fn encode_delete_response(delete_response: DeleteResponse) {
  encode.message(
    [
      encode.bool_field(1, delete_response.success),
      encode.string_field(2, delete_response.message), 
    ],
  )
}



pub fn delete_response_decoder() {
  use success <- decode.then(decode.bool_with_default(1, False))
  use message <- decode.then(decode.string_with_default(2, ""))
  decode.success(DeleteResponse(success: success, message: message))
}



pub fn decode_delete_response(data: BitArray) {
  decode.run(data, delete_response_decoder())
}



pub type ListRequest {
  ListRequest(limit: Int, offset: Int)
}



pub fn encode_list_request(list_request: ListRequest) {
  encode.message(
    [
      encode.int32_field(1, list_request.limit),
      encode.int32_field(2, list_request.offset), 
    ],
  )
}



pub fn list_request_decoder() {
  use limit <- decode.then(decode.int32_with_default(1, 0))
  use offset <- decode.then(decode.int32_with_default(2, 0))
  decode.success(ListRequest(limit: limit, offset: offset))
}



pub fn decode_list_request(data: BitArray) {
  decode.run(data, list_request_decoder())
}



pub type ListResponse {
  ListResponse(temperatures: List(TemperatureResponse), total: Int)
}



pub fn encode_list_response(list_response: ListResponse) {
  {
    let temperatures_fields =
      list.map(
        list_response.temperatures,
        fn(v: TemperatureResponse) {
          encode.field(
            1,
            wire.LengthDelimited,
            encode.length_delimited(encode_temperature_response(v)),
          )
        },
      )
    encode.message(
      list.flatten(
        [temperatures_fields, [encode.int32_field(2, list_response.total)]],
      ),
    )
  }
}



pub fn list_response_decoder() {
  use temperatures <- decode.then(
      decode.repeated_field(
        1,
        fn(field: decode.Field) {
          decode.message_field(_, temperature_response_decoder())(field)
        },
      ),
    )
  use total <- decode.then(decode.int32_with_default(2, 0))
  decode.success(ListResponse(temperatures: temperatures, total: total))
}



pub fn decode_list_response(data: BitArray) {
  decode.run(data, list_response_decoder())
}



// Service: TemperatureService

/// Error type for TemperatureService service
pub type TemperatureServiceError {
  TemperatureServiceNotFound
  TemperatureServiceUnauthorized
  TemperatureServiceBadRequest(String)
  TemperatureServiceInvalidRequest(String)
  TemperatureServiceInternalError(String)
  TemperatureServiceUnavailable(String)
}

/// Auto-generated service for TemperatureService
/// 
/// Layer 1: Core service functions (transport-agnostic BitArray -> Result)
/// Layer 2: HTTP adapters (gleam/http types, returns Result for middleware)
/// 
/// HTTP adapters return Result(Response, ServiceError) for middleware pattern

pub type TemperatureServiceRequestError {
  TemperatureServiceDecodeError(String)
  TemperatureServiceHandlerError(TemperatureServiceError)
}



pub fn get_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) {
  case decode.run(request_bytes, temperature_request_decoder()) {
    Ok(proto_request) -> { case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      } }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to decode TemperatureRequest"),
    )
  }
}



pub fn delete_temperature_service(
  request_bytes: BitArray,
  handler: fn(DeleteRequest) -> Result(DeleteResponse, TemperatureServiceError),
) {
  case decode.run(request_bytes, delete_request_decoder()) {
    Ok(proto_request) -> { case handler(proto_request) {
        Ok(response) -> Ok(encode_delete_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      } }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to decode DeleteRequest"),
    )
  }
}



pub fn create_temperature_service(
  request_bytes: BitArray,
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) {
  case decode.run(request_bytes, temperature_request_decoder()) {
    Ok(proto_request) -> { case handler(proto_request) {
        Ok(response) -> Ok(encode_temperature_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      } }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to decode TemperatureRequest"),
    )
  }
}



pub fn list_temperatures_service(
  request_bytes: BitArray,
  handler: fn(ListRequest) -> Result(ListResponse, TemperatureServiceError),
) {
  case decode.run(request_bytes, list_request_decoder()) {
    Ok(proto_request) -> { case handler(proto_request) {
        Ok(response) -> Ok(encode_list_response(response))
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      } }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to decode ListRequest"),
    )
  }
}



pub fn http_get_temperature(
  req: request.Request(BitArray),
  id: String,
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let celsius = get_query_param_int(query_params, "celsius", 0)
      let location = get_query_param_string(query_params, "location", "")
      let use_cache = get_query_param_bool(query_params, "use_cache", False)
      let precision = get_query_param_float(query_params, "precision", 0.0)
      let proto_request =
        TemperatureRequest(
          id: id,
          celsius: celsius,
          location: location,
          use_cache: use_cache,
          precision: precision,
        )
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_temperature_response(response)
          Ok(
            response.Response(
              status: 200,
              headers: [#("content-type", "application/x-protobuf")],
              body: response_bytes,
            ),
          )
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to parse query parameters"),
    )
  }
}



pub fn http_delete_temperature(
  req: request.Request(BitArray),
  id: String,
  handler: fn(DeleteRequest) -> Result(DeleteResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let proto_request = DeleteRequest(id: id)
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_delete_response(response)
          Ok(
            response.Response(
              status: 200,
              headers: [#("content-type", "application/x-protobuf")],
              body: response_bytes,
            ),
          )
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to parse query parameters"),
    )
  }
}



pub fn http_create_temperature(
  req: request.Request(BitArray),
  handler: fn(TemperatureRequest) -> Result(TemperatureResponse, TemperatureServiceError),
) {
  let request_bytes = req.body
  case create_temperature_service(request_bytes, handler) {
    Ok(response_bytes) -> Ok(
      response.Response(
        status: 200,
        headers: [#("content-type", "application/x-protobuf")],
        body: response_bytes,
      ),
    )
    Error(service_error) -> Error(service_error)
  }
}



pub fn http_list_temperatures(
  req: request.Request(BitArray),
  handler: fn(ListRequest) -> Result(ListResponse, TemperatureServiceError),
) {
  case request.get_query(req) {
    Ok(query_params) -> {
      let limit = get_query_param_int(query_params, "limit", 0)
      let offset = get_query_param_int(query_params, "offset", 0)
      let proto_request = ListRequest(limit: limit, offset: offset)
      case handler(proto_request) {
        Ok(response) -> {
          let response_bytes = encode_list_response(response)
          Ok(
            response.Response(
              status: 200,
              headers: [#("content-type", "application/x-protobuf")],
              body: response_bytes,
            ),
          )
        }
        Error(err) -> Error(TemperatureServiceHandlerError(err))
      }
    }
    Error(_) -> Error(
      TemperatureServiceDecodeError("Failed to parse query parameters"),
    )
  }
}



fn get_query_param_string(
  params: List(#(String, String)),
  key: String,
  default: String,
) -> String {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) -> value
    Error(_) -> default
  }
}



fn get_query_param_int(
  params: List(#(String, String)),
  key: String,
  default: Int,
) -> Int {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) -> case int.parse(value) {
      Ok(i) -> i
      Error(_) -> default
    }
    Error(_) -> default
  }
}



fn get_query_param_bool(
  params: List(#(String, String)),
  key: String,
  default: Bool,
) -> Bool {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) -> case string.lowercase(value) {
      s if s == "true" || s == "1" || s == "yes" -> True
      s if s == "false" || s == "0" || s == "no" -> False
      _ -> default
    }
    Error(_) -> default
  }
}



fn get_query_param_float(
  params: List(#(String, String)),
  key: String,
  default: Float,
) -> Float {
  case list.find(params, fn(p: #(String, String)) { p.0 == key }) {
    Ok(#(_, value)) -> case float.parse(value) {
      Ok(f) -> f
      Error(_) -> default
    }
    Error(_) -> default
  }
}


