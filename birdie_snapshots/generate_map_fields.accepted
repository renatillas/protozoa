---
version: 1.4.0
title: Generate map fields
file: ./test/codegen_test.gleam
test_name: generate_maps_test
---
import gleam/list
import gloto/wire
import gloto/decode
import gloto/encode



pub type MapMessage {
  MapMessage(
  attributes: List(#(String, String)),
  flags: List(#(Int, Bool)),
  objects: List(#(String, NestedValue))
  )
}

pub type NestedValue {
  NestedValue(
  data: String
  )
}

pub fn encode_mapmessage(mapmessage: MapMessage) -> BitArray {
  
  let attributes_fields = list.map(mapmessage.attributes, fn(entry) {
    let #(key, value) = entry
    encode.field(1, wire.LengthDelimited, encode.length_delimited(
      encode.message([
        encode.string_field(1, key),
        encode.string_field(2, value)
      ])
    ))
  })
  let flags_fields = list.map(mapmessage.flags, fn(entry) {
    let #(key, value) = entry
    encode.field(2, wire.LengthDelimited, encode.length_delimited(
      encode.message([
        encode.int32_field(1, key),
        encode.bool_field(2, value)
      ])
    ))
  })
  let objects_fields = list.map(mapmessage.objects, fn(entry) {
    let #(key, value) = entry
    encode.field(3, wire.LengthDelimited, encode.length_delimited(
      encode.message([
        encode.string_field(1, key),
        encode.field(2, wire.LengthDelimited, encode.length_delimited(encode_nestedvalue(value)))
      ])
    ))
  })
  let other_fields = []
  encode.message(list.append(other_fields, list.flatten([attributes_fields, flags_fields, objects_fields])))
}

pub fn encode_nestedvalue(nestedvalue: NestedValue) -> BitArray {
  encode.message([
    encode.string_field(1, nestedvalue.data)
  ])
}

pub fn mapmessage_decoder() -> decode.Decoder(MapMessage) {
  use attributes <- decode.subrecord(decode.repeated_field(1, fn(field) {
    decode.message_field(field, map_entry_1_decoder())
  }))
  use flags <- decode.subrecord(decode.repeated_field(2, fn(field) {
    decode.message_field(field, map_entry_2_decoder())
  }))
  use objects <- decode.subrecord(decode.repeated_field(3, fn(field) {
    decode.message_field(field, map_entry_3_decoder())
  }))
  decode.success(MapMessage(attributes: attributes, flags: flags, objects: objects))
}

pub fn decode_mapmessage(data: BitArray) -> Result(MapMessage, decode.DecodeError) {
  decode.decode(data, mapmessage_decoder())
}

fn map_entry_1_decoder() -> decode.Decoder(#(String, String)) {
  use key <- decode.subrecord(decode.string_with_default(1, ""))
  use value <- decode.subrecord(decode.string_with_default(2, ""))
  decode.success(#(key, value))
}

fn map_entry_2_decoder() -> decode.Decoder(#(Int, Bool)) {
  use key <- decode.subrecord(decode.int32_with_default(1, 0))
  use value <- decode.subrecord(decode.bool_with_default(2, False))
  decode.success(#(key, value))
}

fn map_entry_3_decoder() -> decode.Decoder(#(String, NestedValue)) {
  use key <- decode.subrecord(decode.string_with_default(1, ""))
  use value <- decode.subrecord(decode.nested_message(2, nestedvalue_decoder()))
  decode.success(#(key, value))
}

pub fn nestedvalue_decoder() -> decode.Decoder(NestedValue) {
  use data <- decode.subrecord(decode.string_with_default(1, ""))
  decode.success(NestedValue(data: data))
}

pub fn decode_nestedvalue(data: BitArray) -> Result(NestedValue, decode.DecodeError) {
  decode.decode(data, nestedvalue_decoder())
}


